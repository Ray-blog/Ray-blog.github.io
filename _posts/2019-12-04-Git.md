# git使用方法

# 1.简介

- SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。

- Git是分布式版本控制系统，也有一个“中央服务器”，但每个人的电脑上都是一个完整的版本库，中央服务器的作用仅仅是方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。这样，你工作的时候即使不联网也可以，因为版本库就在你自己的电脑上。当多个人协作时，只需把各自的修改推送给对方，就可以互相看到对方的修改了。

# 2.工作原理

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539915532972-5908412c-7cd5-4f47-9dd6-fe7c6ed49654.png)



**Workspace：工作区**。就是项目所在的文件夹目录。除了隐藏目录.git，这个不算工作区，而是Git的版本库。

**Index / Stage：暂存区**。用于存储工作区中添加上来的变更（新增、修改、删除）的文件的地方。

**Repository：本地仓库**。包含了Git为我们自动创建的第一个分支master，和指向master的一个指针HEAD。 用于存储暂存区提交上来的变更（新增、修改、删除）过的文件的地方。

**Remote：远程仓库**。托管在网络上（ GitHub，GitLab 等）的项目仓库，可能会有好多个。其中有些你只能读，另外有些可以写。同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。值得一提的是，只有pull，fetch，clone，push4个命令和远程仓库有交互，也就是说需要联网，其他的命令都是在本地完成的，不需要联网。

# 3.初始化配置

开始使用Git之前，我们首先要用git config命令设置一下git的配置变量，主要有以下几步：

**(****1)**创建本地版本库，git clone下来的项目可以忽略的可以忽略

​     git init

**(****2)**配置姓名和email地址，提交的时候作为用户的标识(必须)

​     git config --global user.name "wang"

​     git config --global user.email "wang@gmail.com"

**(3)**设置一些别名，以便使用更为简洁的子命令

​     **①**git config --global alias.ci commit

​     **②**git config --global alias.st status

​     **③**git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"

# 4.本地提交

**(1)**新建了一个a.txt的文件，并向其中添加11111，通过git status查看文件状态。可以看见文件未被追踪

   ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539916062720-72ae4f03-b5d7-45d2-9eef-ad6641c2fa80.png)

**(2)**git add a.txt用于将文件添加进暂存区进行追踪。这时文件就可以提交了。git add **.**表示将修改的文件添加进暂存区

   ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539916385405-2e259670-b75e-41f7-be9b-038451ae3d25.png)

**(3)**添加进暂存区的文件此时可以使用git commit -m "本次提交注释" 添加进本地仓库。注释是必须要提交的，不加-m会默认打开vim，让你编辑本次提交的注释

   ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539916506866-59672ab7-01d0-445c-a898-72eaea72da1e.png)

**(4)**git diff用于比较两次修改的差异，比如此时我继续修改文件，添加了22222，然后运行git diff，可以看见以下差异，红色的代表和暂存区中的a.txt相比较删减的部分，绿色的代表增加的部分

   ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539916855786-29dce5a1-eb71-4430-b330-bfb950ac170c.png)

   git diff主要有以下用法：

   **①**比较工作区与暂存区：

​      git diff 不加参数即默认比较工作区与暂存区

　 **②**比较暂存区与最新本地仓库（本地仓库中最近一次commit的内容）:

​      git diff --cached <file>

   **③**比较工作区与最新本地仓库

​      git diff HEAD <file>  如果HEAD指向的是master分支，那么HEAD还可以换成master

   **④**比较工作区与指定commit-id的差异

​      git diff <commit-id> <file>

​    **⑤**比较暂存区与指定commit-id的差异

​      git diff --cached <commit-id> <file>

　 **⑥**比较两个commit-id之间的差异

​      git diff <commit-id> <commit-id>

# 5.撤销暂存区

撤销暂存区文件。已将a.txt添加到暂存区，此时想把他从暂存区删除，使用git rm --cached a.txt。注意： git rm --cached file仅仅会删除暂存区的文件，并不会删除本地工作区的文件，想要删除工作区和暂存区的文件，使用git rm file1 file2 ...

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539918022601-ff1d8afd-5b07-49e4-b96c-81d8df18b4f6.png)

# 6.修改最近一次本地提交

修改最近一次已经commit的文件。如果上一次提交的注释或者内容有误，可以使用git commit --amend -m "修改的提交的注释"

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539918152470-c100cf8c-e611-42c5-8159-146499d86210.png)

# 7.撤销本地修改和撤销删除文件

### (1)撤销本地修改

假设我在a.txt中增加了一行内容33333，此时我发现增加的33333内容有误，所以我得马上恢复以前的版本，使用

git checkout -- a.txt可以把a.txt在工作区做的修改全部撤销，但是撤销的状态有以下两种情况：

**情况****①**： a.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和本地仓库一模一样的状态

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539918327054-6c933a13-c16a-4be0-8945-8786daced364.png)

**情况②**：一种是a.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

### (2)撤销删除文件

撤销（恢复）不小心删除的文件。同样是通过git checkout -- a.txt，恢复之后文件的状态和上面撤销本地修改的两种情况一样

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539918588447-59a88aa4-d20e-45c4-8407-437b765dc878.png)

**总结：** git checkout -- file就是让这个文件回到最近一次git commit或git add时的状态

# 8.版本回退

### (1)git reset **--soft** commitId

**--soft**仅仅只是撤销已提交的本地仓库，不会修改暂存区和工作区。下面我们做了3次提交，并且第4次工作区的修改已经add到了暂存区。我们通过**--soft**将版本回退到第二次提交。

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539919034767-ee9b05e8-c571-4700-a33f-79ad67a5352f.png)![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539919108088-bb5482d3-6496-477e-b45a-2d19cea3eb75.png)



### (2)git reset **--mixed** commitId

此为默认方式，等于不加参数git reset commitId，**--mixed**会撤销已提交的本地仓库和暂存区，不会修改工作区。下面我们做了2次提交，并且第3次工作区的修改已经add到了暂存区。我们通过**--mixed**将版本回退到第一次提交。

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539919310948-0e0b8e99-5a0e-4903-ad28-9141927df0cb.png)

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539919314333-ddf6ace6-5700-435c-b145-64527d7c12e8.png)



### (3)git reset **--hard** commitId

**--hard**会彻底将工作区、暂存区和本地仓库记录恢复到指定的版本，此种方法比较危险，需小心使用。下面我们做了2次提交，并且第3次工作区的修改已经add到了暂存区。我们通过**--hard**将版本回退到第一次提交。

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539919603080-0947bb83-844c-46d4-8d05-73692708174a.png)

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539919606406-44bc2684-af19-42b8-bccb-f34d734d1ab2.png)

# 9.分支

分支( branches ) 是指在开发主线中分离出来，基于原有分支创建，做进一步开发而不影响到原来主线。

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539919780314-027cb5ea-e130-4ccf-82d3-ae06095e868e.png)

GIT分支包括本地分支跟远程分支，常用命令如下：（除了最后一条push命令和远程仓库有互动，删除了远程仓库的分支，其他的远程分支都是指的是本地仓库中的远程分支，即下图中蓝色框内的分支）

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539920534746-07829e06-6b82-4757-a47e-586ed88e03a1.png)

- 列出所有本地分支：git branch

- 列出所有远程分支：git branch -r

- 列出所有本地分支和远程分支：git branch -a

- 新建一个分支，但依然停留在当前分支：git branch [branch-name]

- 新建一个分支，并切换到该分支 ：git checkout -b [branch]

- 新建一个分支，指向指定commit：git branch [branch] [commit]

- 切换到指定分支，并更新工作区： git checkout [branch-name]

- 建立现有分支与远程分支的追踪关系：git branch --set-upstream [branch] [remote-branch]

- 合并指定分支到当前分支：git merge [branch]

- 选择一个commit，合并进当前分支 ：git cherry-pick [commit]

- 删除本地分支： git branch -d [branch-name]

- 删除远程分支：git push origin --delete [branch-name]

# 10.远程仓库

### (1)直接clone已有远程仓库

git clone https://github.com/haishancheng/gitTest.git

### (2)推送本地已有项目到远程仓库

**①**首先通过git remote add origin https://github.com/haishancheng/gitTest.git，设置远程仓库地址对应为origin字段

**②**继而通过git push -u origin master，将本地仓库的master分支推送到远程master分支

**③**git push使用说明

  git push origin master，将本地的master分支推送到远程的master分支

  git push origin master:dev，将本地的master分支推送到远程的dev分支

  git push origin :master 等同于 git push origin --delete master，推送一个空的本地分支到远程master分支。表示删除指定的远程分支

### (3)配置ssh key

上述的push使用的https的传输协议，每次push都要输入远程仓库的账号密码，非常的麻烦。配置SSH传输协议可以在push的时候不用输入密码。

**①**创建SSHKey，通过ssh-keygen -t rsa -b 4096 -C "your_email@example.com"创建一对公私秘钥。在用户主目录里找到.ssh目录（cd ~/.ssh），里面有id_rsa和id_rsa.pub两个文件，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，用于配置到git代码托管网站。

**②**配置公钥，以GitHub为例，打开用户"Settings"，选取"SSH andGPG Keys"。然后点击"New SSHKey"，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。

# 11.拉取合并

### (1)git pull

用于拉取远程仓库某个分支的更新，再与本地的指定分支合并使用说明

**①**git pull origin dev:master，取回origin主机的dev分支，与本地的master分支合并

**②**git pull origin dev，远程分支(dev)要与当前分支合并，则冒号后面的部分可以省略。取回远程dev分支，再与当前分支合并

### (2)git pull origin dev 拆解

git pull实际上是由git fetch + git merge两步的合成，具体过程如下

**①**首先通过git branch -a可以查看本地仓库所有分支

  ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539930093738-fd930471-8d6e-4636-ac6f-054fd486ca45.png)

**②**git fetch origin dev，拉取远程仓库dev分支(拉取所有分支：git fetch origin)，存储到本地仓库中的相对应的远程分支(origin/dev)  

**③**git merge origin/dev ，将本地仓库中的远程分支合并到本地当前分支

### (3)git pull --rebase origin dev拆解

类似git pull， git pull --rebase由git fetch + git rebase两步的合成，它是另一种拉取合并的方法，rebase和merge两种合并的方法的用法以及不同之处请看下个章节。

### (4)git fetch 使用总结

git fetch实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态，git fetch并不会更新你的当前分支，也不会修改你磁盘上的文件。

# 12.合并分支方法

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539931820607-5f731c20-527c-4025-b319-40746d59e149.png)

### (1)merge

​     目前有master和dev两个分支，每个分支上各提交了两次，提交记录如下图。现在要把dev分支合并到master分支，并且目前处于master分支。

​     ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539930645081-04c0930f-f694-4aa2-a46d-d081ca3e86db.png)

​     **(1)**使用 git merge dev：merge是合并的意思，将dev和当前分支（master）合并

​         ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539930694540-1ca81031-2c3b-440c-9a1f-faa412ff4a30.png)

​     **(2)**使用merge合并后提交记录如下

​         ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539930725168-d560253c-d323-477c-a248-e86395c48d2b.png)

​     **(3)**可以看出merge有以下几个特点

​         **①**保留了完整的历史记录

​         **②**引入了一次新的合并的历史记录，因为每次merge会自动产生一个新的合并的历史记录，所以在使用一些git的GUItools，特别是commit比较频繁时，看到分支很杂乱

​         **③**处理一次冲突

​          **④**当前分支（master）会指向最新提交点，被合并分支（dev）指向不变

### (2)rebase

​     目前有master和dev两个分支，每个分支上各提交了两次，提交记录如下图。现在要把dev分支合并到master分支，并且目前处于master分支。

​     ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539931263365-9a21de08-0830-4849-aa31-1a6a1efa5178.png)

​     **(1)**使用 git rebase master dev：rebase意为变基，让dev分支相对于master进行变基。或者切换到dev分支下，执行git rebase master，即让当前分支相对于master进行变基

​          ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539931392688-660e4be5-4c87-4545-8d8b-06db43aa53f9.png)

​     **(2)**使用rebase合并后提交记录如下

​          ![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539931423933-ff993b02-1718-4c61-965e-9aad8ce78a75.png)

​     **(3)**可以看出rebase有以下几个特点

​         **①**改变了历史记录

​         **②**提交记录变成了一条线，项目历史非常的简洁

​          **③**可能会多次解决同一个地方的冲突，因为每个提交点都需要变基

​          **④**rebase之后指向的是变基的分支，master分支仍然不是最新，需要使用git rebase dev master，将master指向最新

​          **⑤**git rebase的黄金法则：绝不要在公共的分支上使用它，即不能把公共分支rebase到别的分支上去。比如说，

如果你把master分支rebase到你的dev分支上，这次rebase将master分支上的所有提交都移到了dev分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的master上工作。因为rebase引起了新的提交，git会认为你的master分支和其他人的master已经分叉了。

### (3)cherry-pick

git cherry-pick可以理解为“挑拣”提交进行合并，它会获取某一个分支的一个或几个提交来进行操作，并作为一个新的提交引入到你当前分支上。当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次或几次提交合入到本地当前分支上，那么就要使用git cherry-pick了。



例如下面的例子：git cherry-pick c2 c4，可以将side分支的c2，c4提交点，合并到当前的分支（master）

![img](https://cdn.nlark.com/yuque/0/2018/png/193541/1539932024099-99a5da10-9524-4766-af37-5788cb1c64e7.png)

# 13.推荐网站

[Learn Git Branching](https://learngitbranching.js.org/)